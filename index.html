<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Agar Lite</title>
<style>
body{margin:0;overflow:hidden;background:#111}
canvas{background:#151515}
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
class Network {
    constructor(game){
        this.game = game;
        this.ws = new WebSocket("wss://api.agar.su:6001");
        this.ws.binaryType = "arraybuffer";
        this.ws.onmessage = e => this.onMessage(e);
    }

    onMessage(e){
        const view = new DataView(e.data);
        let o = 0;
        const id = view.getUint8(o++);

        // HELLO
        if(id === 0){
            this.game.myId = view.getUint16(o,true); // Uint16 !!!
            return;
        }

        if(id !== 2) return;

        // map size Uint16
        this.game.mapSize = view.getUint16(o,true); 
        o += 2;

        // FOODS (Uint16 coords)
        const foodCount = view.getUint16(o,true); 
        o += 2;

        this.game.foods = [];
        for(let i=0;i<foodCount;i++){
            this.game.foods.push({
                x: view.getUint16(o,true),
                y: view.getUint16(o+2,true)
            });
            o += 4;
        }

        // PLAYERS (Uint16 everything)
        const playerCount = view.getUint16(o,true); 
        o += 2;

        const snapshot = {
            time: performance.now(),
            players: []
        };

        for(let i=0;i<playerCount;i++){
            snapshot.players.push({
                id: view.getUint16(o,true),
                x: view.getUint16(o+2,true),
                y: view.getUint16(o+4,true),
                mass: view.getUint16(o+6,true)
            });
            o += 8;
        }

        this.game.snapshots.push(snapshot);

        while(this.game.snapshots.length > 40)
            this.game.snapshots.shift();
    }

    // ⭐ новый супер-маленький input пакет (3 байта)
    sendDirection(dx,dy){
        const buf = new ArrayBuffer(3);
        const view = new DataView(buf);
        view.setUint8(0,1);

        // нормализуем -1..1 → -127..127
        view.setInt8(1, dx*127);
        view.setInt8(2, dy*127);

        this.ws.send(buf);
    }
}


class Camera {
    constructor(game){
        this.game = game;
        this.x = 0;
        this.y = 0;

        // текущий zoom (что рисуем)
        this.zoom = 1;

        // целевой zoom (куда хотим прийти)
        this.targetZoom = 1;

        this.minZoom = 0.09;
        this.maxZoom = 2.5;

        this.zoomSpeed = 0.12;   // чувствительность колесика
        this.smooth = 0.12;      // ⭐ плавность (0.05–0.2 идеально)
    }

    update(){
        const me = this.game.renderPlayers.get(this.game.myId);
        if(!me) return;

        // камера следует за игроком
        this.x = me.x;
        this.y = me.y;

        // ⭐ ПЛАВНЫЙ ZOOM (lerp)
        this.zoom += (this.targetZoom - this.zoom) * this.smooth;
    }

    addZoom(delta){
        // меняем ЦЕЛЕВОЙ зум, а не текущий
        this.targetZoom *= (1 - delta * this.zoomSpeed);

        // clamp
        this.targetZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.targetZoom));
    }
}


class Input {
    constructor(canvas, network){
        this.canvas = canvas;
        this.network = network;
        canvas.onmousemove = e => this.onMouseMove(e);
		canvas.onwheel = e => this.onWheel(e);
    }
	onWheel(e){
    e.preventDefault();

    // deltaY > 0 → колесо вниз → zoom out
    const delta = Math.sign(e.deltaY);

    this.network.game.camera.addZoom(delta);
}


    onMouseMove(e){
        const dx = e.clientX - this.canvas.width/2;
        const dy = e.clientY - this.canvas.height/2;
        const dist = Math.hypot(dx,dy) || 1;
        this.network.sendDirection(dx/dist, dy/dist);
    }
}

class Renderer {
    constructor(game, canvas){
        this.game = game;
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
    }

    resize(){
        this.canvas.width = innerWidth;
        this.canvas.height = innerHeight;
    }

    draw(){
        const {ctx, canvas, game} = this;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();

// ⭐ сначала центрируем экран
ctx.translate(canvas.width/2, canvas.height/2);

// ⭐ применяем zoom
ctx.scale(game.camera.zoom, game.camera.zoom);

// ⭐ потом двигаем мир
ctx.translate(-game.camera.x, -game.camera.y);


        // map border
        ctx.strokeStyle="#555";
        ctx.strokeRect(0,0,game.mapSize,game.mapSize);

        // foods
        ctx.fillStyle="#0f0";
        game.foods.forEach(f=>{
            ctx.beginPath();
            ctx.arc(f.x,f.y,3,0,Math.PI*2);
            ctx.fill();
        });

        // ⭐ PLAYERS (renderPlayers!)
        game.renderPlayers.forEach(p=>{
            ctx.fillStyle = p.id===game.myId ? "#ff0" : "#09f";
            ctx.beginPath();
            ctx.arc(p.x,p.y,p.mass,0,Math.PI*2);
            ctx.fill();
        });

        ctx.restore();
    }
}

class Game {
    constructor(){
        this.canvas = document.getElementById("c");

        this.myId = null;
        this.mapSize = 20000;
        this.foods = [];

        // ⭐ agar interpolation system
        this.snapshots = [];
        this.renderPlayers = new Map();
        this.INTERP_DELAY = 150; // 120-200ms стандарт

        this.network = new Network(this);
        this.camera = new Camera(this);
        this.renderer = new Renderer(this, this.canvas);
        this.input = new Input(this.canvas, this.network);

        window.onresize = () => this.renderer.resize();
        this.renderer.resize();

        requestAnimationFrame(()=>this.loop());
    }

    // ищем снапшоты вокруг времени рендера
    getSnapshotsForRender(){
        const renderTime = performance.now() - this.INTERP_DELAY;
        const snaps = this.snapshots;

        if(snaps.length < 2) return null;

        for(let i=0;i<snaps.length-1;i++){
            const a = snaps[i];
            const b = snaps[i+1];

            if(a.time <= renderTime && b.time >= renderTime){
                const t = (renderTime - a.time) / (b.time - a.time);
                return {a,b,t};
            }
        }
        return null;
    }

    // ⭐ интерполяция игроков
    interpolateWorld(){
        const data = this.getSnapshotsForRender();
        if(!data) return;

        const {a,b,t} = data;
        this.renderPlayers.clear();

        for(const newP of b.players){
            const oldP = a.players.find(p=>p.id===newP.id);
            if(!oldP) continue;

            const x = oldP.x + (newP.x-oldP.x)*t;
            const y = oldP.y + (newP.y-oldP.y)*t;
            const m = oldP.mass + (newP.mass-oldP.mass)*t;

            this.renderPlayers.set(newP.id,{
                id:newP.id,
                x,y,mass:m
            });
        }
    }

    loop(){
        this.interpolateWorld();
        this.camera.update();
        this.renderer.draw();
        requestAnimationFrame(()=>this.loop());
    }
}

new Game();


</script>
</body>
</html>
