<!DOCTYPE html>
<html>
<head>
  <title>Slither - —Ç–µ—Å—Ç–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ</title>
  <link rel="icon" href="icon.svg" type="image/svg+xml">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { margin:0; background:#0a0a0a; overflow:hidden; font-family:Arial; color:white; }
    canvas { display:block; cursor:crosshair; }
    #leaderboard {
      position:absolute; top:10px; right:10px; background:rgba(0,0,0,0.8); padding:15px; border-radius:10px;
      min-width:200px; max-height:300px; overflow-y:auto; font-size:14px;
    }
    #leaderboard h3 { margin:0 0 10px; text-align:center; }
    #leaderboard div { display:flex; justify-content:space-between; margin:5px 0; gap:2px;flex-direction: column;}
    #minimap {
      position:absolute; bottom:10px; right:10px; background:rgba(0,0,0,0.8); border-radius:5px; padding:5px;
    }
    #minimap canvas { border:1px solid #333; border-radius:3px; }
    #name-input { position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.9); padding:20px; border-radius:10px; display:none; }
    input { background:#333; color:white; border:1px solid #555; padding:10px; border-radius:5px; width:200px; }
    button { background:#4a4a4a; color:white; border:1px solid #666; padding:10px 20px; border-radius:5px; cursor:pointer; margin-left:10px; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="leaderboard">
    <h3>Leaderboard</h3>
    <div id="lb-list"></div>
  </div>
  <div id="minimap">
    <canvas id="minimap-canvas" width="200" height="200"></canvas>
    <div style="text-align:center; font-size:12px;">Minimap</div>
  </div>
  <div id="name-input">
    <input id="name-field" placeholder="Enter your name" maxlength="15">
    <button onclick="setName()">Play</button>
  </div>
  <script>
document.addEventListener('keydown', function (event) {
  if (event.key === 'Escape') {
    const menu = document.getElementById('name-input');

    if (menu.style.display === 'none') {
      menu.style.display = 'block';
    } else {
      menu.style.display = 'none';
    }
  }
});
</script>


<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const minimapCanvas = document.getElementById('minimap-canvas');
const minimapCtx = minimapCanvas.getContext('2d');
const lbList = document.getElementById('lb-list');
const nameInput = document.getElementById('name-input');
const nameField = document.getElementById('name-field');

let ws = new WebSocket('wss://ffa.agar.su:6009');
let myId = null;
let mapSize = 0;
let snakes = {};
let foods = [];
let leaderboard = [];

let mouseX = 0, mouseY = 0;
let boosting = false;
let zoom = 1.5;
let myHead = {x:0,y:0};
let wasAlive = false;
  
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// Input
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left - canvas.width / 2;
  mouseY = e.clientY - rect.top - canvas.height / 2;
  sendInput();
});

// Space boost
window.addEventListener('keydown', e => {
  if (e.code === 'Space' && document.activeElement !== nameField) {
    e.preventDefault();
    boosting = true;
    sendInput();
  }
});

window.addEventListener('keyup', e => {
  if (e.code === 'Space') {
    boosting = false;
    sendInput();
  }
});

// Zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  zoom *= e.deltaY > 0 ? 0.9 : 1.1;
  zoom = Math.max(0.05, Math.min(5, zoom));
});

function sendInput() {
  if (!myId || !ws.readyState) return;
  if (!snakes[myId]) return;
  const angle = Math.atan2(mouseY, mouseX);
  ws.send(JSON.stringify({ type: 'input', angle, boosting }));
}

ws.onopen = () => console.log('Connected!');
ws.onmessage = (msg) => {
  const data = JSON.parse(msg.data);
  if (data.type === 'init') {
    myId = data.id;
    mapSize = data.mapSize;
    nameInput.style.display = 'block';
    document.getElementById('name-field').focus();
} else if (data.type === 'state') {
  snakes = data.snakes;
  foods = data.foods;
  leaderboard = data.leaderboard;
  updateLeaderboard();

  if (myId && snakes[myId]) {
    myHead = snakes[myId].parts[0];
    wasAlive = true;
  } else {
    // üíÄ —Ç—ã —É–º–µ—Ä
    if (wasAlive) {
      document.getElementById('name-input').style.display = 'block';
      wasAlive = false;
    }
  }
}

};

function setName() {
  const name = nameField.value.trim() || 'Anon';
  ws.send(JSON.stringify({ type: 'name', name }));
  nameInput.style.display = 'none';
}

function updateLeaderboard() {
  lbList.innerHTML = '';
  leaderboard.forEach((player, i) => {
    const div = document.createElement('div');
    div.innerHTML = `<span>#${i+1} ${player.name} ${player.score}</span>`;
    div.style.color = player.color;
    lbList.appendChild(div);
  });
}

function drawMain() {
  const w = canvas.width;
  const h = canvas.height;

  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, w, h);

  if (!myId || !snakes[myId]) {
    requestAnimationFrame(drawMain);
    return;
  }

  ctx.save();
  ctx.translate(w / 2, h / 2);
  ctx.scale(zoom, zoom);
  ctx.translate(-myHead.x, -myHead.y);
  
// ===== –ö–†–ê–°–ù–ê–Ø –ì–†–ê–ù–ò–¶–ê –ö–ê–†–¢–´ =====
ctx.strokeStyle = 'red';
ctx.lineWidth = 8; // —Ç–æ–ª—â–∏–Ω–∞ –Ω–µ –º–µ–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –∑—É–º–µ
ctx.strokeRect(0, 0, mapSize, mapSize);
// =================================

  // –ï–¥–∞ (Agar.io —Å—Ç–∏–ª—å - —Ç–æ—á–∫–∏)
foods.forEach(food => {
  ctx.fillStyle = food.color;
  ctx.beginPath();
  ctx.arc(food.x, food.y, food.size, 0, Math.PI * 2);  // –ò—Å–ø–æ–ª—å–∑—É–µ–º food.size –¥–ª—è —Ä–∞–¥–∏—É—Å–∞
  ctx.fill();
});


  // –ó–º–µ–π–∫–∏
  for (let id in snakes) {
    const snake = snakes[id];
    if (!snake.parts || snake.parts.length === 0) continue;

    const head = snake.parts[0];
    const tail = snake.parts[snake.parts.length - 1];

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º diameter —Å —Å–µ—Ä–≤–µ—Ä–∞ (–æ–Ω —É–∂–µ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –∫–∞–∫ BASE_DIAMETER + DIAMETER_SCALING * (length - 1))
    const diameter = snake.diameter || 20; // –Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –ø–æ –∫–∞–∫–æ–π-—Ç–æ –ø—Ä–∏—á–∏–Ω–µ –Ω–µ –ø—Ä–∏—à–ª–æ

    // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ —Ä–∞–∑–º–µ—Ä—ã
    const bodyWidth = Math.max(10, diameter * 1.0);     // –æ—Å–Ω–æ–≤–Ω–∞—è –ª–∏–Ω–∏—è —Ç–µ–ª–∞
    const fadeWidth = Math.max(8, diameter * 0.85);     // –≥—Ä–∞–¥–∏–µ–Ω—Ç —á—É—Ç—å —Ç–æ–Ω—å—à–µ
    const headRadius = Math.max(10, diameter / 2);      // —Ä–∞–¥–∏—É—Å –≥–æ–ª–æ–≤—ã = –ø–æ–ª–æ–≤–∏–Ω–∞ –¥–∏–∞–º–µ—Ç—Ä–∞
    const eyeOffset = headRadius * 0.65;                // –≥–ª–∞–∑–∞ –±–ª–∏–∂–µ –∫ –∫—Ä–∞—é –±–æ–ª—å—à–æ–π –≥–æ–ª–æ–≤—ã
    const eyeSize = Math.max(3, headRadius * 0.35);
    const pupilSize = Math.max(1.5, headRadius * 0.15);

    // ===== –¢–ï–õ–û (—Å –∑–∞—â–∏—Ç–æ–π –æ—Ç wrap-–±–∞–≥–æ–≤) =====
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    // --- –û—Å–Ω–æ–≤–Ω–∞—è –ª–∏–Ω–∏—è —Ç–µ–ª–∞ ---
    ctx.strokeStyle = snake.color;
    ctx.lineWidth = bodyWidth;
    ctx.beginPath();
    for (let i = 0; i < snake.parts.length; i++) {
      const p = snake.parts[i];
      if (i === 0) {
        ctx.moveTo(p.x, p.y);
        continue;
      }
      const prev = snake.parts[i - 1];
      const dx = Math.abs(p.x - prev.x);
      const dy = Math.abs(p.y - prev.y);
      if (dx > mapSize / 2 || dy > mapSize / 2) {
        ctx.moveTo(p.x, p.y);
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    ctx.stroke();

    // --- –ì—Ä–∞–¥–∏–µ–Ω—Ç —Ö–≤–æ—Å—Ç–∞ (–ø–ª–∞–≤–Ω–æ–µ –∑–∞—Ç–µ–º–Ω–µ–Ω–∏–µ –∫ —á—ë—Ä–Ω–æ–º—É) ---
    const grad = ctx.createLinearGradient(
      head.x, head.y,
      tail.x, tail.y
    );
    grad.addColorStop(0, snake.color);
    grad.addColorStop(1, '#000');

    ctx.strokeStyle = grad;
    ctx.lineWidth = fadeWidth;
    ctx.beginPath();
    for (let i = 0; i < snake.parts.length; i++) {
      const p = snake.parts[i];
      if (i === 0) {
        ctx.moveTo(p.x, p.y);
        continue;
      }
      const prev = snake.parts[i - 1];
      const dx = Math.abs(p.x - prev.x);
      const dy = Math.abs(p.y - prev.y);
      if (dx > mapSize / 2 || dy > mapSize / 2) {
        ctx.moveTo(p.x, p.y);
      } else {
        ctx.lineTo(p.x, p.y);
      }
    }
    ctx.stroke();

    // ===== –ì–û–õ–û–í–ê =====
    ctx.fillStyle = snake.color;
    ctx.beginPath();
    ctx.arc(head.x, head.y, headRadius, 0, Math.PI * 2);
    ctx.fill();

    // ===== –ì–õ–ê–ó–ê =====
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(
      head.x + Math.cos(snake.angle - 0.4) * eyeOffset,
      head.y + Math.sin(snake.angle - 0.4) * eyeOffset,
      eyeSize, 0, Math.PI * 2
    );
    ctx.arc(
      head.x + Math.cos(snake.angle + 0.4) * eyeOffset,
      head.y + Math.sin(snake.angle + 0.4) * eyeOffset,
      eyeSize, 0, Math.PI * 2
    );
    ctx.fill();

    // –ó—Ä–∞—á–∫–∏
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(
      head.x + Math.cos(snake.angle - 0.4) * eyeOffset,
      head.y + Math.sin(snake.angle - 0.4) * eyeOffset,
      pupilSize, 0, Math.PI * 2
    );
    ctx.arc(
      head.x + Math.cos(snake.angle + 0.4) * eyeOffset,
      head.y + Math.sin(snake.angle + 0.4) * eyeOffset,
      pupilSize, 0, Math.PI * 2
    );
    ctx.fill();

    // ===== –ù–ò–ö =====
    ctx.fillStyle = 'white';
    ctx.font = `bold 20px Arial`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(snake.name, head.x, head.y - (headRadius + 15));

    // ===== BOOST –ò–ù–î–ò–ö–ê–¢–û–† (—Ç–æ–ª—å–∫–æ –¥–ª—è —Å–≤–æ–µ–π –∑–º–µ–∏) =====
    if (id === myId && snake.boostCharge !== undefined) {
      const barWidth = 80;
      const barHeight = 10;
      const barX = head.x - barWidth / 2;
      const barY = head.y + headRadius + 15;

      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.fillRect(barX, barY, barWidth, barHeight);

      ctx.fillStyle = '#0f0';
      ctx.fillRect(barX, barY, (snake.boostCharge / 200) * barWidth, barHeight);
    }
  }


  ctx.restore();
}

function drawMinimap() {
  const mcw = 200, mch = 200;
  minimapCtx.fillStyle = '#001122';
  minimapCtx.fillRect(0, 0, mcw, mch);

  const scale = mcw / mapSize;

  // –ò–≥—Ä–æ–∫–∏ (—Ç–æ—á–∫–∏)
  for (let id in snakes) {
    const head = snakes[id].parts[0];
    minimapCtx.fillStyle = id === myId ? '#fff' : snakes[id].color;
    minimapCtx.beginPath();
    minimapCtx.arc(head.x * scale, head.y * scale, id === myId ? 4 : 2, 0, Math.PI * 2);
    minimapCtx.fill();
  }

  // My view rect
  if (myId && snakes[myId]) {
    const head = snakes[myHead];
    const vw = canvas.width / zoom / mapSize * mcw;
    const vh = canvas.height / zoom / mapSize * mch;
    minimapCtx.strokeStyle = '#fff';
    minimapCtx.lineWidth = 2;
    minimapCtx.strokeRect(
      (myHead.x - canvas.width / (2 * zoom)) * scale,
      (myHead.y - canvas.height / (2 * zoom)) * scale,
      vw, vh
    );
  }
}

function loop() {
  drawMain();
  drawMinimap();
  requestAnimationFrame(loop);
}
loop();

setInterval(sendInput, 40);
</script>
</body>
</html>
